#include "nfc_device_i.h"

#include <storage/storage.h>
#include <flipper_format/flipper_format.h>

#include "nfc_common.h"
#include "protocols/nfc_device_defs.h"

#define NFC_FILE_HEADER "Flipper NFC device"
#define NFC_DEV_TYPE_ERROR "Protocol type mismatch"

#define NFC_DEVICE_UID_KEY "UID"
#define NFC_DEVICE_TYPE_KEY "Device type"

#define NFC_DEVICE_UID_MAX_LEN (10U)

NfcDevice* nfc_device_alloc() {
    NfcDevice* instance = malloc(sizeof(NfcDevice));
    instance->protocol = NfcProtocolInvalid;

    return instance;
}

void nfc_device_free(NfcDevice* instance) {
    furi_assert(instance);

    nfc_device_clear(instance);
    free(instance);
}

void nfc_device_clear(NfcDevice* instance) {
    furi_assert(instance);

    if(instance->protocol == NfcProtocolInvalid) {
        furi_assert(instance->protocol_data == NULL);
    } else if(instance->protocol < NfcProtocolNum) {
        if(instance->protocol_data) {
            nfc_devices[instance->protocol]->free(instance->protocol_data);
            instance->protocol_data = NULL;
        }
        instance->protocol = NfcProtocolInvalid;
    }
}

void nfc_device_reset(NfcDevice* instance) {
    furi_assert(instance);
    furi_assert(instance->protocol < NfcProtocolNum);

<<<<<<< HEAD
static bool nfc_device_save_mifare_ul_data(FlipperFormat* file, NfcDevice* dev) {
    bool saved = false;
    MfUltralightData* data = &dev->dev_data.mf_ul_data;
    FuriString* temp_str;
    temp_str = furi_string_alloc();

    // Save Mifare Ultralight specific data
    do {
        if(!flipper_format_write_comment_cstr(file, "Mifare Ultralight specific data")) break;
        if(!flipper_format_write_uint32(
               file, "Data format version", &nfc_mifare_ultralight_data_format_version, 1))
            break;
        if(!flipper_format_write_hex(file, "Signature", data->signature, sizeof(data->signature)))
            break;
        if(!flipper_format_write_hex(
               file, "Mifare version", (uint8_t*)&data->version, sizeof(data->version)))
            break;
        // Write conters and tearing flags data
        bool counters_saved = true;
        for(uint8_t i = 0; i < 3; i++) {
            furi_string_printf(temp_str, "Counter %d", i);
            if(!flipper_format_write_uint32(
                   file, furi_string_get_cstr(temp_str), &data->counter[i], 1)) {
                counters_saved = false;
                break;
            }
            furi_string_printf(temp_str, "Tearing %d", i);
            if(!flipper_format_write_hex(
                   file, furi_string_get_cstr(temp_str), &data->tearing[i], 1)) {
                counters_saved = false;
                break;
            }
        }
        if(!counters_saved) break;
        // Write pages data
        uint32_t pages_total = data->data_size / 4;
        if(!flipper_format_write_uint32(file, "Pages total", &pages_total, 1)) break;
        uint32_t pages_read = data->data_read / 4;
        if(!flipper_format_write_uint32(file, "Pages read", &pages_read, 1)) break;
        bool pages_saved = true;
        for(uint16_t i = 0; i < data->data_size; i += 4) {
            furi_string_printf(temp_str, "Page %d", i / 4);
            if(!flipper_format_write_hex(file, furi_string_get_cstr(temp_str), &data->data[i], 4)) {
                pages_saved = false;
                break;
            }
        }
        if(!pages_saved) break;

        // Write authentication counter
        uint32_t auth_counter = data->curr_authlim;
        if(!flipper_format_write_uint32(file, "Failed authentication attempts", &auth_counter, 1))
            break;

        saved = true;
    } while(false);

    furi_string_free(temp_str);
    return saved;
}

bool nfc_device_load_mifare_ul_data(FlipperFormat* file, NfcDevice* dev) {
    bool parsed = false;
    MfUltralightData* data = &dev->dev_data.mf_ul_data;
    FuriString* temp_str;
    temp_str = furi_string_alloc();
    uint32_t data_format_version = 0;

    do {
        // Read Mifare Ultralight format version
        if(!flipper_format_read_uint32(file, "Data format version", &data_format_version, 1)) {
            if(!flipper_format_rewind(file)) break;
        }

        // Read signature
        if(!flipper_format_read_hex(file, "Signature", data->signature, sizeof(data->signature)))
            break;
        // Read Mifare version
        if(!flipper_format_read_hex(
               file, "Mifare version", (uint8_t*)&data->version, sizeof(data->version)))
            break;
        // Read counters and tearing flags
        bool counters_parsed = true;
        for(uint8_t i = 0; i < 3; i++) {
            furi_string_printf(temp_str, "Counter %d", i);
            if(!flipper_format_read_uint32(
                   file, furi_string_get_cstr(temp_str), &data->counter[i], 1)) {
                counters_parsed = false;
                break;
            }
            furi_string_printf(temp_str, "Tearing %d", i);
            if(!flipper_format_read_hex(
                   file, furi_string_get_cstr(temp_str), &data->tearing[i], 1)) {
                counters_parsed = false;
                break;
            }
        }
        if(!counters_parsed) break;
        // Read pages
        uint32_t pages_total = 0;
        if(!flipper_format_read_uint32(file, "Pages total", &pages_total, 1)) break;
        uint32_t pages_read = 0;
        if(data_format_version < nfc_mifare_ultralight_data_format_version) {
            pages_read = pages_total;
        } else {
            if(!flipper_format_read_uint32(file, "Pages read", &pages_read, 1)) break;
        }
        data->data_size = pages_total * 4;
        data->data_read = pages_read * 4;
        if(data->data_size > MF_UL_MAX_DUMP_SIZE || data->data_read > MF_UL_MAX_DUMP_SIZE) break;
        bool pages_parsed = true;
        for(uint16_t i = 0; i < pages_total; i++) {
            furi_string_printf(temp_str, "Page %d", i);
            if(!flipper_format_read_hex(
                   file, furi_string_get_cstr(temp_str), &data->data[i * 4], 4)) {
                pages_parsed = false;
                break;
            }
        }
        if(!pages_parsed) break;

        // Read authentication counter
        uint32_t auth_counter;
        if(!flipper_format_read_uint32(file, "Failed authentication attempts", &auth_counter, 1))
            auth_counter = 0;
        data->curr_authlim = auth_counter;

        data->auth_success = mf_ul_is_full_capture(data);

        parsed = true;
    } while(false);

    furi_string_free(temp_str);
    return parsed;
}

static bool nfc_device_save_mifare_df_key_settings(
    FlipperFormat* file,
    MifareDesfireKeySettings* ks,
    const char* prefix) {
    bool saved = false;
    FuriString* key;
    key = furi_string_alloc();

    do {
        furi_string_printf(key, "%s Change Key ID", prefix);
        if(!flipper_format_write_hex(file, furi_string_get_cstr(key), &ks->change_key_id, 1))
            break;
        furi_string_printf(key, "%s Config Changeable", prefix);
        if(!flipper_format_write_bool(file, furi_string_get_cstr(key), &ks->config_changeable, 1))
            break;
        furi_string_printf(key, "%s Free Create Delete", prefix);
        if(!flipper_format_write_bool(file, furi_string_get_cstr(key), &ks->free_create_delete, 1))
            break;
        furi_string_printf(key, "%s Free Directory List", prefix);
        if(!flipper_format_write_bool(file, furi_string_get_cstr(key), &ks->free_directory_list, 1))
            break;
        furi_string_printf(key, "%s Key Changeable", prefix);
        if(!flipper_format_write_bool(
               file, furi_string_get_cstr(key), &ks->master_key_changeable, 1))
            break;
        if(ks->flags) {
            furi_string_printf(key, "%s Flags", prefix);
            if(!flipper_format_write_hex(file, furi_string_get_cstr(key), &ks->flags, 1)) break;
        }
        furi_string_printf(key, "%s Max Keys", prefix);
        if(!flipper_format_write_hex(file, furi_string_get_cstr(key), &ks->max_keys, 1)) break;
        for(MifareDesfireKeyVersion* kv = ks->key_version_head; kv; kv = kv->next) {
            furi_string_printf(key, "%s Key %d Version", prefix, kv->id);
            if(!flipper_format_write_hex(file, furi_string_get_cstr(key), &kv->version, 1)) break;
        }
        saved = true;
    } while(false);

    furi_string_free(key);
    return saved;
}

bool nfc_device_load_mifare_df_key_settings(
    FlipperFormat* file,
    MifareDesfireKeySettings* ks,
    const char* prefix) {
    bool parsed = false;
    FuriString* key;
    key = furi_string_alloc();

    do {
        furi_string_printf(key, "%s Change Key ID", prefix);
        if(!flipper_format_read_hex(file, furi_string_get_cstr(key), &ks->change_key_id, 1)) break;
        furi_string_printf(key, "%s Config Changeable", prefix);
        if(!flipper_format_read_bool(file, furi_string_get_cstr(key), &ks->config_changeable, 1))
            break;
        furi_string_printf(key, "%s Free Create Delete", prefix);
        if(!flipper_format_read_bool(file, furi_string_get_cstr(key), &ks->free_create_delete, 1))
            break;
        furi_string_printf(key, "%s Free Directory List", prefix);
        if(!flipper_format_read_bool(file, furi_string_get_cstr(key), &ks->free_directory_list, 1))
            break;
        furi_string_printf(key, "%s Key Changeable", prefix);
        if(!flipper_format_read_bool(
               file, furi_string_get_cstr(key), &ks->master_key_changeable, 1))
            break;
        furi_string_printf(key, "%s Flags", prefix);
        if(flipper_format_key_exist(file, furi_string_get_cstr(key))) {
            if(!flipper_format_read_hex(file, furi_string_get_cstr(key), &ks->flags, 1)) break;
        }
        furi_string_printf(key, "%s Max Keys", prefix);
        if(!flipper_format_read_hex(file, furi_string_get_cstr(key), &ks->max_keys, 1)) break;
        ks->flags |= ks->max_keys >> 4;
        ks->max_keys &= 0xF;
        MifareDesfireKeyVersion** kv_head = &ks->key_version_head;
        for(int key_id = 0; key_id < ks->max_keys; key_id++) {
            furi_string_printf(key, "%s Key %d Version", prefix, key_id);
            uint8_t version;
            if(flipper_format_read_hex(file, furi_string_get_cstr(key), &version, 1)) {
                MifareDesfireKeyVersion* kv = malloc(sizeof(MifareDesfireKeyVersion));
                memset(kv, 0, sizeof(MifareDesfireKeyVersion));
                kv->id = key_id;
                kv->version = version;
                *kv_head = kv;
                kv_head = &kv->next;
            }
        }
        parsed = true;
    } while(false);

    furi_string_free(key);
    return parsed;
}

static bool nfc_device_save_mifare_df_app(FlipperFormat* file, MifareDesfireApplication* app) {
    bool saved = false;
    FuriString *prefix, *key;
    prefix =
        furi_string_alloc_printf("Application %02x%02x%02x", app->id[0], app->id[1], app->id[2]);
    key = furi_string_alloc();
    uint8_t* tmp = NULL;

    do {
        if(app->key_settings) {
            if(!nfc_device_save_mifare_df_key_settings(
                   file, app->key_settings, furi_string_get_cstr(prefix)))
                break;
        }
        if(!app->file_head) break;
        uint32_t n_files = 0;
        for(MifareDesfireFile* f = app->file_head; f; f = f->next) {
            n_files++;
        }
        tmp = malloc(n_files);
        int i = 0;
        for(MifareDesfireFile* f = app->file_head; f; f = f->next) {
            tmp[i++] = f->id;
        }
        furi_string_printf(key, "%s File IDs", furi_string_get_cstr(prefix));
        if(!flipper_format_write_hex(file, furi_string_get_cstr(key), tmp, n_files)) break;
        bool saved_files = true;
        for(MifareDesfireFile* f = app->file_head; f; f = f->next) {
            saved_files = false;
            furi_string_printf(key, "%s File %d Type", furi_string_get_cstr(prefix), f->id);
            if(!flipper_format_write_hex(file, furi_string_get_cstr(key), &f->type, 1)) break;
            furi_string_printf(
                key, "%s File %d Communication Settings", furi_string_get_cstr(prefix), f->id);
            if(!flipper_format_write_hex(file, furi_string_get_cstr(key), &f->comm, 1)) break;
            furi_string_printf(
                key, "%s File %d Access Rights", furi_string_get_cstr(prefix), f->id);
            if(!flipper_format_write_hex(
                   file, furi_string_get_cstr(key), (uint8_t*)&f->access_rights, 2))
                break;
            uint16_t size = 0;
            if(f->type == MifareDesfireFileTypeStandard ||
               f->type == MifareDesfireFileTypeBackup) {
                size = f->settings.data.size;
                furi_string_printf(key, "%s File %d Size", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_write_uint32(
                       file, furi_string_get_cstr(key), &f->settings.data.size, 1))
                    break;
            } else if(f->type == MifareDesfireFileTypeValue) {
                furi_string_printf(
                    key, "%s File %d Hi Limit", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_write_uint32(
                       file, furi_string_get_cstr(key), &f->settings.value.hi_limit, 1))
                    break;
                furi_string_printf(
                    key, "%s File %d Lo Limit", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_write_uint32(
                       file, furi_string_get_cstr(key), &f->settings.value.lo_limit, 1))
                    break;
                furi_string_printf(
                    key, "%s File %d Limited Credit Value", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_write_uint32(
                       file, furi_string_get_cstr(key), &f->settings.value.limited_credit_value, 1))
                    break;
                furi_string_printf(
                    key, "%s File %d Limited Credit Enabled", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_write_bool(
                       file,
                       furi_string_get_cstr(key),
                       &f->settings.value.limited_credit_enabled,
                       1))
                    break;
                size = 4;
            } else if(
                f->type == MifareDesfireFileTypeLinearRecord ||
                f->type == MifareDesfireFileTypeCyclicRecord) {
                furi_string_printf(key, "%s File %d Size", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_write_uint32(
                       file, furi_string_get_cstr(key), &f->settings.record.size, 1))
                    break;
                furi_string_printf(key, "%s File %d Max", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_write_uint32(
                       file, furi_string_get_cstr(key), &f->settings.record.max, 1))
                    break;
                furi_string_printf(key, "%s File %d Cur", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_write_uint32(
                       file, furi_string_get_cstr(key), &f->settings.record.cur, 1))
                    break;
                size = f->settings.record.size * f->settings.record.cur;
            }
            if(f->contents) {
                furi_string_printf(key, "%s File %d", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_write_hex(file, furi_string_get_cstr(key), f->contents, size))
                    break;
            }
            saved_files = true;
        }
        if(!saved_files) {
            break;
        }
        saved = true;
    } while(false);

    free(tmp);
    furi_string_free(prefix);
    furi_string_free(key);
    return saved;
}

bool nfc_device_load_mifare_df_app(FlipperFormat* file, MifareDesfireApplication* app) {
    bool parsed = false;
    FuriString *prefix, *key;
    prefix =
        furi_string_alloc_printf("Application %02x%02x%02x", app->id[0], app->id[1], app->id[2]);
    key = furi_string_alloc();
    uint8_t* tmp = NULL;
    MifareDesfireFile* f = NULL;

    do {
        app->key_settings = malloc(sizeof(MifareDesfireKeySettings));
        memset(app->key_settings, 0, sizeof(MifareDesfireKeySettings));
        if(!nfc_device_load_mifare_df_key_settings(
               file, app->key_settings, furi_string_get_cstr(prefix))) {
            free(app->key_settings);
            app->key_settings = NULL;
            break;
        }
        furi_string_printf(key, "%s File IDs", furi_string_get_cstr(prefix));
        uint32_t n_files;
        if(!flipper_format_get_value_count(file, furi_string_get_cstr(key), &n_files)) break;
        tmp = malloc(n_files);
        if(!flipper_format_read_hex(file, furi_string_get_cstr(key), tmp, n_files)) break;
        MifareDesfireFile** file_head = &app->file_head;
        bool parsed_files = true;
        for(uint32_t i = 0; i < n_files; i++) {
            parsed_files = false;
            f = malloc(sizeof(MifareDesfireFile));
            memset(f, 0, sizeof(MifareDesfireFile));
            f->id = tmp[i];
            furi_string_printf(key, "%s File %d Type", furi_string_get_cstr(prefix), f->id);
            if(!flipper_format_read_hex(file, furi_string_get_cstr(key), &f->type, 1)) break;
            furi_string_printf(
                key, "%s File %d Communication Settings", furi_string_get_cstr(prefix), f->id);
            if(!flipper_format_read_hex(file, furi_string_get_cstr(key), &f->comm, 1)) break;
            furi_string_printf(
                key, "%s File %d Access Rights", furi_string_get_cstr(prefix), f->id);
            if(!flipper_format_read_hex(
                   file, furi_string_get_cstr(key), (uint8_t*)&f->access_rights, 2))
                break;
            if(f->type == MifareDesfireFileTypeStandard ||
               f->type == MifareDesfireFileTypeBackup) {
                furi_string_printf(key, "%s File %d Size", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_read_uint32(
                       file, furi_string_get_cstr(key), &f->settings.data.size, 1))
                    break;
            } else if(f->type == MifareDesfireFileTypeValue) {
                furi_string_printf(
                    key, "%s File %d Hi Limit", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_read_uint32(
                       file, furi_string_get_cstr(key), &f->settings.value.hi_limit, 1))
                    break;
                furi_string_printf(
                    key, "%s File %d Lo Limit", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_read_uint32(
                       file, furi_string_get_cstr(key), &f->settings.value.lo_limit, 1))
                    break;
                furi_string_printf(
                    key, "%s File %d Limited Credit Value", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_read_uint32(
                       file, furi_string_get_cstr(key), &f->settings.value.limited_credit_value, 1))
                    break;
                furi_string_printf(
                    key, "%s File %d Limited Credit Enabled", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_read_bool(
                       file,
                       furi_string_get_cstr(key),
                       &f->settings.value.limited_credit_enabled,
                       1))
                    break;
            } else if(
                f->type == MifareDesfireFileTypeLinearRecord ||
                f->type == MifareDesfireFileTypeCyclicRecord) {
                furi_string_printf(key, "%s File %d Size", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_read_uint32(
                       file, furi_string_get_cstr(key), &f->settings.record.size, 1))
                    break;
                furi_string_printf(key, "%s File %d Max", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_read_uint32(
                       file, furi_string_get_cstr(key), &f->settings.record.max, 1))
                    break;
                furi_string_printf(key, "%s File %d Cur", furi_string_get_cstr(prefix), f->id);
                if(!flipper_format_read_uint32(
                       file, furi_string_get_cstr(key), &f->settings.record.cur, 1))
                    break;
            }
            furi_string_printf(key, "%s File %d", furi_string_get_cstr(prefix), f->id);
            if(flipper_format_key_exist(file, furi_string_get_cstr(key))) {
                uint32_t size;
                if(!flipper_format_get_value_count(file, furi_string_get_cstr(key), &size)) break;
                f->contents = malloc(size);
                if(!flipper_format_read_hex(file, furi_string_get_cstr(key), f->contents, size))
                    break;
            }
            *file_head = f;
            file_head = &f->next;
            f = NULL;
            parsed_files = true;
        }
        if(!parsed_files) {
            break;
        }
        parsed = true;
    } while(false);

    if(f) {
        free(f->contents);
        free(f);
    }
    free(tmp);
    furi_string_free(prefix);
    furi_string_free(key);
    return parsed;
}

static bool nfc_device_save_mifare_df_data(FlipperFormat* file, NfcDevice* dev) {
    bool saved = false;
    MifareDesfireData* data = &dev->dev_data.mf_df_data;
    uint8_t* tmp = NULL;

    do {
        if(!flipper_format_write_comment_cstr(file, "Mifare DESFire specific data")) break;
        if(!flipper_format_write_hex(
               file, "PICC Version", (uint8_t*)&data->version, sizeof(data->version)))
            break;
        if(data->free_memory) {
            if(!flipper_format_write_uint32(file, "PICC Free Memory", &data->free_memory->bytes, 1))
                break;
        }
        if(data->master_key_settings) {
            if(!nfc_device_save_mifare_df_key_settings(file, data->master_key_settings, "PICC"))
                break;
        }
        uint32_t n_apps = 0;
        for(MifareDesfireApplication* app = data->app_head; app; app = app->next) {
            n_apps++;
        }
        if(!flipper_format_write_uint32(file, "Application Count", &n_apps, 1)) break;
        if(n_apps) {
            tmp = malloc(n_apps * 3);
            int i = 0;
            for(MifareDesfireApplication* app = data->app_head; app; app = app->next) {
                memcpy(tmp + i, app->id, 3); //-V769
                i += 3;
            }
            if(!flipper_format_write_hex(file, "Application IDs", tmp, n_apps * 3)) break;
            for(MifareDesfireApplication* app = data->app_head; app; app = app->next) {
                if(!nfc_device_save_mifare_df_app(file, app)) break;
            }
        }
        saved = true;
    } while(false);

    free(tmp);
    return saved;
}

bool nfc_device_load_mifare_df_data(FlipperFormat* file, NfcDevice* dev) {
    bool parsed = false;
    MifareDesfireData* data = &dev->dev_data.mf_df_data;
    memset(data, 0, sizeof(MifareDesfireData));
    uint8_t* tmp = NULL;

    do {
        if(!flipper_format_read_hex(
               file, "PICC Version", (uint8_t*)&data->version, sizeof(data->version)))
            break;
        if(flipper_format_key_exist(file, "PICC Free Memory")) {
            data->free_memory = malloc(sizeof(MifareDesfireFreeMemory));
            memset(data->free_memory, 0, sizeof(MifareDesfireFreeMemory));
            if(!flipper_format_read_uint32(
                   file, "PICC Free Memory", &data->free_memory->bytes, 1)) {
                free(data->free_memory);
                break;
            }
        }
        if(flipper_format_key_exist(file, "PICC Change Key ID")) {
            data->master_key_settings = malloc(sizeof(MifareDesfireKeySettings));
            memset(data->master_key_settings, 0, sizeof(MifareDesfireKeySettings));
            if(!nfc_device_load_mifare_df_key_settings(file, data->master_key_settings, "PICC")) {
                free(data->master_key_settings);
                data->master_key_settings = NULL;
                break;
            }
        }
        uint32_t n_apps;
        if(!flipper_format_read_uint32(file, "Application Count", &n_apps, 1)) break;
        if(n_apps) {
            tmp = malloc(n_apps * 3);
            if(!flipper_format_read_hex(file, "Application IDs", tmp, n_apps * 3)) break;
            bool parsed_apps = true;
            MifareDesfireApplication** app_head = &data->app_head;
            for(uint32_t i = 0; i < n_apps; i++) {
                MifareDesfireApplication* app = malloc(sizeof(MifareDesfireApplication));
                memset(app, 0, sizeof(MifareDesfireApplication));
                memcpy(app->id, &tmp[i * 3], 3);
                if(!nfc_device_load_mifare_df_app(file, app)) {
                    free(app);
                    parsed_apps = false;
                    break;
                }
                *app_head = app;
                app_head = &app->next;
            }
            if(!parsed_apps) {
                // accept non-parsed apps, just log a warning:
                FURI_LOG_W(TAG, "Non-parsed apps found!");
            }
        }
        parsed = true;
    } while(false);

    free(tmp);
    return parsed;
}


static bool nfc_device_save_slix_data(
    FlipperFormat* file,
    NfcDevice* dev,
    SlixTypeFeatures features,
    const char* type) {
    bool saved = false;
    NfcVSlixData* data = &dev->dev_data.nfcv_data.sub_data.slix;

    do {
        char msg[64];
        snprintf(msg, sizeof(msg), "%s specific data", type);
        if(!flipper_format_write_comment_cstr(file, msg)) break;
        if(!flipper_format_write_comment_cstr(
               file, "Passwords are optional. If password is omitted, any password is accepted"))
            break;

        if(features & SlixFeatureRead) {
            if(data->flags & NfcVSlixDataFlagsHasKeyRead) {
                if(!flipper_format_write_hex(
                       file, "Password Read", data->key_read, sizeof(data->key_read)))
                    break;
            }
        }
        if(features & SlixFeatureWrite) {
            if(data->flags & NfcVSlixDataFlagsHasKeyWrite) {
                if(!flipper_format_write_hex(
                       file, "Password Write", data->key_write, sizeof(data->key_write)))
                    break;
            }
        }
        if(features & SlixFeaturePrivacy) {
            if(data->flags & NfcVSlixDataFlagsHasKeyPrivacy) {
                if(!flipper_format_write_hex(
                       file, "Password Privacy", data->key_privacy, sizeof(data->key_privacy)))
                    break;
            }
        }
        if(features & SlixFeatureDestroy) {
            if(data->flags & NfcVSlixDataFlagsHasKeyDestroy) {
                if(!flipper_format_write_hex(
                       file, "Password Destroy", data->key_destroy, sizeof(data->key_destroy)))
                    break;
            }
        }
        if(features & SlixFeatureEas) {
            if(data->flags & NfcVSlixDataFlagsHasKeyEas) {
                if(!flipper_format_write_hex(
                       file, "Password EAS", data->key_eas, sizeof(data->key_eas)))
                    break;
            }
        }
        if(features & SlixFeatureSignature) {
            if(!flipper_format_write_comment_cstr(
                   file,
                   "This is the card's secp128r1 elliptic curve signature. It can not be calculated without knowing NXP's private key."))
                break;
            if(!flipper_format_write_hex(
                   file, "Signature", data->signature, sizeof(data->signature)))
                break;
        }
        if(features & SlixFeaturePrivacy) {
            bool privacy = (data->flags & NfcVSlixDataFlagsPrivacy) ? true : false;
            if(!flipper_format_write_bool(file, "Privacy Mode", &privacy, 1)) break;
        }
        if(features & SlixFeatureProtection) {
            if(!flipper_format_write_comment_cstr(file, "Protection pointer configuration")) break;
            if(!flipper_format_write_hex(file, "Protection pointer", &data->pp_pointer, 1)) break;
            if(!flipper_format_write_hex(file, "Protection condition", &data->pp_condition, 1))
                break;
        }
        saved = true;
    } while(false);

    return saved;
}

bool nfc_device_load_slix_data(FlipperFormat* file, NfcDevice* dev, SlixTypeFeatures features) {
    bool parsed = false;
    NfcVSlixData* data = &dev->dev_data.nfcv_data.sub_data.slix;
    memset(data, 0, sizeof(NfcVSlixData));

    do {
        data->flags = 0;

        if(features & SlixFeatureRead) {
            if(flipper_format_key_exist(file, "Password Read")) {
                if(!flipper_format_read_hex(
                       file, "Password Read", data->key_read, sizeof(data->key_read))) {
                    FURI_LOG_D(TAG, "Failed reading Password Read");
                    break;
                }
                data->flags |= NfcVSlixDataFlagsHasKeyRead;
            }
        }
        if(features & SlixFeatureWrite) {
            if(flipper_format_key_exist(file, "Password Write")) {
                if(!flipper_format_read_hex(
                       file, "Password Write", data->key_write, sizeof(data->key_write))) {
                    FURI_LOG_D(TAG, "Failed reading Password Write");
                    break;
                }
                data->flags |= NfcVSlixDataFlagsHasKeyWrite;
            }
        }
        if(features & SlixFeaturePrivacy) {
            if(flipper_format_key_exist(file, "Password Privacy")) {
                if(!flipper_format_read_hex(
                       file, "Password Privacy", data->key_privacy, sizeof(data->key_privacy))) {
                    FURI_LOG_D(TAG, "Failed reading Password Privacy");
                    break;
                }
                data->flags |= NfcVSlixDataFlagsHasKeyPrivacy;
            }
        }
        if(features & SlixFeatureDestroy) {
            if(flipper_format_key_exist(file, "Password Destroy")) {
                if(!flipper_format_read_hex(
                       file, "Password Destroy", data->key_destroy, sizeof(data->key_destroy))) {
                    FURI_LOG_D(TAG, "Failed reading Password Destroy");
                    break;
                }
                data->flags |= NfcVSlixDataFlagsHasKeyDestroy;
            }
        }
        if(features & SlixFeatureEas) {
            if(flipper_format_key_exist(file, "Password EAS")) {
                if(!flipper_format_read_hex(
                       file, "Password EAS", data->key_eas, sizeof(data->key_eas))) {
                    FURI_LOG_D(TAG, "Failed reading Password EAS");
                    break;
                }
                data->flags |= NfcVSlixDataFlagsHasKeyEas;
            }
        }
        if(features & SlixFeatureSignature) {
            if(!flipper_format_read_hex(
                   file, "Signature", data->signature, sizeof(data->signature))) {
                FURI_LOG_D(TAG, "Failed reading Signature");
                break;
            }
        }
        if(features & SlixFeaturePrivacy) {
            bool privacy;
            if(!flipper_format_read_bool(file, "Privacy Mode", &privacy, 1)) {
                FURI_LOG_D(TAG, "Failed reading Privacy Mode");
                break;
            }
            if(privacy) {
                data->flags |= NfcVSlixDataFlagsPrivacy;
            }
        }
        if(features & SlixFeatureProtection) {
            if(!flipper_format_read_hex(file, "Protection pointer", &(data->pp_pointer), 1)) {
                FURI_LOG_D(TAG, "Failed reading Protection pointer");
                break;
            }
            if(!flipper_format_read_hex(file, "Protection condition", &(data->pp_condition), 1)) {
                FURI_LOG_D(TAG, "Failed reading Protection condition");
                break;
            }
        }
        parsed = true;
    } while(false);

    return parsed;
}

static bool nfc_device_save_nfcv_data(FlipperFormat* file, NfcDevice* dev) {
    bool saved = false;
    NfcVData* data = &dev->dev_data.nfcv_data;

    do {
        uint32_t temp_uint32 = 0;
        uint8_t temp_uint8 = 0;

        if(!flipper_format_write_comment_cstr(file, "Data Storage Format Identifier")) break;
        if(!flipper_format_write_hex(file, "DSFID", &(data->dsfid), 1)) break;
        if(!flipper_format_write_comment_cstr(file, "Application Family Identifier")) break;
        if(!flipper_format_write_hex(file, "AFI", &(data->afi), 1)) break;
        if(!flipper_format_write_hex(file, "IC Reference", &(data->ic_ref), 1)) break;
        temp_uint32 = data->block_num;
        if(!flipper_format_write_comment_cstr(file, "Number of memory blocks, usually 0 to 256"))
            break;
        if(!flipper_format_write_uint32(file, "Block Count", &temp_uint32, 1)) break;
        if(!flipper_format_write_comment_cstr(file, "Size of a single memory block, usually 4"))
            break;
        if(!flipper_format_write_hex(file, "Block Size", &(data->block_size), 1)) break;
        if(!flipper_format_write_hex(
               file, "Data Content", data->data, data->block_num * data->block_size))
            break;
        if(!flipper_format_write_comment_cstr(
               file,
               "First byte: DSFID (0x01) / AFI (0x02) / EAS (0x04) / PPL (0x08) lock info, others: block lock info"))
            break;
        if(!flipper_format_write_hex(
               file, "Security Status", data->security_status, 1 + data->block_num))
            break;
        if(!flipper_format_write_comment_cstr(
               file,
               "Subtype of this card (0 = ISO15693, 1 = SLIX, 2 = SLIX-S, 3 = SLIX-L, 4 = SLIX2)"))
            break;
        temp_uint8 = (uint8_t)data->sub_type;
        if(!flipper_format_write_hex(file, "Subtype", &temp_uint8, 1)) break;

        switch(data->sub_type) {
        case NfcVTypePlain:
            if(!flipper_format_write_comment_cstr(file, "End of ISO15693 parameters")) break;
            saved = true;
            break;
        case NfcVTypeSlix:
            saved = nfc_device_save_slix_data(file, dev, SlixFeatureSlix, "SLIX");
            break;
        case NfcVTypeSlixS:
            saved = nfc_device_save_slix_data(file, dev, SlixFeatureSlixS, "SLIX-S");
            break;
        case NfcVTypeSlixL:
            saved = nfc_device_save_slix_data(file, dev, SlixFeatureSlixL, "SLIX-L");
            break;
        case NfcVTypeSlix2:
            saved = nfc_device_save_slix_data(file, dev, SlixFeatureSlix2, "SLIX2");
            break;
        default:
            break;
        }
    } while(false);

    return saved;
}

bool nfc_device_load_nfcv_data(FlipperFormat* file, NfcDevice* dev) {
    bool parsed = false;
    NfcVData* data = &dev->dev_data.nfcv_data;

    memset(data, 0x00, sizeof(NfcVData));

    do {
        uint32_t temp_uint32 = 0;
        uint8_t temp_value = 0;

        if(!flipper_format_read_hex(file, "DSFID", &(data->dsfid), 1)) {
            FURI_LOG_D(TAG, "Failed reading DSFID");
            break;
        }
        if(!flipper_format_read_hex(file, "AFI", &(data->afi), 1)) {
            FURI_LOG_D(TAG, "Failed reading AFI");
            break;
        }
        if(!flipper_format_read_hex(file, "IC Reference", &(data->ic_ref), 1)) {
            FURI_LOG_D(TAG, "Failed reading IC Reference");
            break;
        }
        if(!flipper_format_read_uint32(file, "Block Count", &temp_uint32, 1)) {
            FURI_LOG_D(TAG, "Failed reading Block Count");
            break;
        }
        data->block_num = temp_uint32;
        if(!flipper_format_read_hex(file, "Block Size", &(data->block_size), 1)) {
            FURI_LOG_D(TAG, "Failed reading Block Size");
            break;
        }
        if(!flipper_format_read_hex(
               file, "Data Content", data->data, data->block_num * data->block_size)) {
            FURI_LOG_D(TAG, "Failed reading Data Content");
            break;
        }

        /* optional, as added later */
        if(flipper_format_key_exist(file, "Security Status")) {
            if(!flipper_format_read_hex(
                   file, "Security Status", data->security_status, 1 + data->block_num)) {
                FURI_LOG_D(TAG, "Failed reading Security Status");
                break;
            }
        }
        if(!flipper_format_read_hex(file, "Subtype", &temp_value, 1)) {
            FURI_LOG_D(TAG, "Failed reading Subtype");
            break;
        }
        data->sub_type = temp_value;

        switch(data->sub_type) {
        case NfcVTypePlain:
            parsed = true;
            break;
        case NfcVTypeSlix:
            parsed = nfc_device_load_slix_data(file, dev, SlixFeatureSlix);
            break;
        case NfcVTypeSlixS:
            parsed = nfc_device_load_slix_data(file, dev, SlixFeatureSlixS);
            break;
        case NfcVTypeSlixL:
            parsed = nfc_device_load_slix_data(file, dev, SlixFeatureSlixL);
            break;
        case NfcVTypeSlix2:
            parsed = nfc_device_load_slix_data(file, dev, SlixFeatureSlix2);
            break;
        default:
            break;
        }
    } while(false);

    return parsed;
}

static bool nfc_device_save_bank_card_data(FlipperFormat* file, NfcDevice* dev) {
    bool saved = false;
    EmvData* data = &dev->dev_data.emv_data;
    uint32_t data_temp = 0;

    do {
        // Write Bank card specific data
        if(!flipper_format_write_comment_cstr(file, "Bank card specific data")) break;
        if(!flipper_format_write_hex(file, "AID", data->aid, data->aid_len)) break;
        if(!flipper_format_write_string_cstr(file, "Name", data->name)) break;
        if(!flipper_format_write_hex(file, "Number", data->number, data->number_len)) break;
        if(data->exp_mon) {
            uint8_t exp_data[2] = {data->exp_mon, data->exp_year};
            if(!flipper_format_write_hex(file, "Exp data", exp_data, sizeof(exp_data))) break;
        }
        if(data->country_code) {
            data_temp = data->country_code;
            if(!flipper_format_write_uint32(file, "Country code", &data_temp, 1)) break;
        }
        if(data->currency_code) {
            data_temp = data->currency_code;
            if(!flipper_format_write_uint32(file, "Currency code", &data_temp, 1)) break;
        }
        saved = true;
    } while(false);

    return saved;
}


// Leave for backward compatibility
bool nfc_device_load_bank_card_data(FlipperFormat* file, NfcDevice* dev) {
    bool parsed = false;
    EmvData* data = &dev->dev_data.emv_data;
    memset(data, 0, sizeof(EmvData));
    uint32_t data_cnt = 0;
    FuriString* temp_str;
    temp_str = furi_string_alloc();

    do {
        // Load essential data
        if(!flipper_format_get_value_count(file, "AID", &data_cnt)) break;
        data->aid_len = data_cnt;
        if(!flipper_format_read_hex(file, "AID", data->aid, data->aid_len)) break;
        if(!flipper_format_read_string(file, "Name", temp_str)) break;
        strlcpy(data->name, furi_string_get_cstr(temp_str), sizeof(data->name));
        if(!flipper_format_get_value_count(file, "Number", &data_cnt)) break;
        data->number_len = data_cnt;
        if(!flipper_format_read_hex(file, "Number", data->number, data->number_len)) break;
        parsed = true;
        // Load optional data
        uint8_t exp_data[2] = {};
        if(flipper_format_read_hex(file, "Exp data", exp_data, 2)) {
            data->exp_mon = exp_data[0];
            data->exp_year = exp_data[1];
        }
        if(flipper_format_read_uint32(file, "Country code", &data_cnt, 1)) {
            data->country_code = data_cnt;
        }
        if(flipper_format_read_uint32(file, "Currency code", &data_cnt, 1)) {
            data->currency_code = data_cnt;
        }
    } while(false);

    furi_string_free(temp_str);
    return parsed;
}

static void nfc_device_write_mifare_classic_block(
    FuriString* block_str,
    MfClassicData* data,
    uint8_t block_num) {
    furi_string_reset(block_str);
    bool is_sec_trailer = mf_classic_is_sector_trailer(block_num);
    if(is_sec_trailer) {
        uint8_t sector_num = mf_classic_get_sector_by_block(block_num);
        MfClassicSectorTrailer* sec_tr = mf_classic_get_sector_trailer_by_sector(data, sector_num);
        // Write key A
        for(size_t i = 0; i < sizeof(sec_tr->key_a); i++) {
            if(mf_classic_is_key_found(data, sector_num, MfClassicKeyA)) {
                furi_string_cat_printf(block_str, "%02X ", sec_tr->key_a[i]);
            } else {
                furi_string_cat_printf(block_str, "?? ");
            }
        }
        // Write Access bytes
        for(size_t i = 0; i < MF_CLASSIC_ACCESS_BYTES_SIZE; i++) {
            if(mf_classic_is_block_read(data, block_num)) {
                furi_string_cat_printf(block_str, "%02X ", sec_tr->access_bits[i]);
            } else {
                furi_string_cat_printf(block_str, "?? ");
            }
        }
        // Write key B
        for(size_t i = 0; i < sizeof(sec_tr->key_b); i++) {
            if(mf_classic_is_key_found(data, sector_num, MfClassicKeyB)) {
                furi_string_cat_printf(block_str, "%02X ", sec_tr->key_b[i]);
            } else {
                furi_string_cat_printf(block_str, "?? ");
            }
        }
    } else {
        // Write data block
        for(size_t i = 0; i < MF_CLASSIC_BLOCK_SIZE; i++) {
            if(mf_classic_is_block_read(data, block_num)) {
                furi_string_cat_printf(block_str, "%02X ", data->block[block_num].value[i]);
            } else {
                furi_string_cat_printf(block_str, "?? ");
            }
        }
    }
    furi_string_trim(block_str);
}

static bool nfc_device_save_mifare_classic_data(FlipperFormat* file, NfcDevice* dev) {
    bool saved = false;
    MfClassicData* data = &dev->dev_data.mf_classic_data;
    FuriString* temp_str;
    temp_str = furi_string_alloc();
    uint16_t blocks = 0;

    // Save Mifare Classic specific data
    do {
        if(!flipper_format_write_comment_cstr(file, "Mifare Classic specific data")) break;

        if(data->type == MfClassicTypeMini) {
            if(!flipper_format_write_string_cstr(file, "Mifare Classic type", "MINI")) break;
            blocks = 20;
        } else if(data->type == MfClassicType1k) {
            if(!flipper_format_write_string_cstr(file, "Mifare Classic type", "1K")) break;
            blocks = 64;
        } else if(data->type == MfClassicType4k) {
            if(!flipper_format_write_string_cstr(file, "Mifare Classic type", "4K")) break;
            blocks = 256;
        }
        if(!flipper_format_write_uint32(
               file, "Data format version", &nfc_mifare_classic_data_format_version, 1))
            break;
        if(!flipper_format_write_comment_cstr(
               file, "Mifare Classic blocks, \'??\' means unknown data"))
            break;
        bool block_saved = true;
        FuriString* block_str;
        block_str = furi_string_alloc();
        for(size_t i = 0; i < blocks; i++) {
            furi_string_printf(temp_str, "Block %d", i);
            nfc_device_write_mifare_classic_block(block_str, data, i);
            if(!flipper_format_write_string(file, furi_string_get_cstr(temp_str), block_str)) {
                block_saved = false;
                break;
            }
        }
        furi_string_free(block_str);
        if(!block_saved) break;
        saved = true;
    } while(false);

    furi_string_free(temp_str);
    return saved;
}

static void nfc_device_load_mifare_classic_block(
    FuriString* block_str,
    MfClassicData* data,
    uint8_t block_num) {
    furi_string_trim(block_str);
    MfClassicBlock block_tmp = {};
    bool is_sector_trailer = mf_classic_is_sector_trailer(block_num);
    uint8_t sector_num = mf_classic_get_sector_by_block(block_num);
    uint16_t block_unknown_bytes_mask = 0;

    furi_string_trim(block_str);
    for(size_t i = 0; i < MF_CLASSIC_BLOCK_SIZE; i++) {
        char hi = furi_string_get_char(block_str, 3 * i);
        char low = furi_string_get_char(block_str, 3 * i + 1);
        uint8_t byte = 0;
        if(hex_char_to_uint8(hi, low, &byte)) {
            block_tmp.value[i] = byte;
        } else {
            FURI_BIT_SET(block_unknown_bytes_mask, i);
        }
    }

    if(block_unknown_bytes_mask == 0xffff) {
        // All data is unknown, exit
        return;
    }

    if(is_sector_trailer) {
        MfClassicSectorTrailer* sec_tr_tmp = (MfClassicSectorTrailer*)&block_tmp;
        // Load Key A
        // Key A mask 0b0000000000111111 = 0x003f
        if((block_unknown_bytes_mask & 0x003f) == 0) {
            uint64_t key = nfc_util_bytes2num(sec_tr_tmp->key_a, sizeof(sec_tr_tmp->key_a));
            mf_classic_set_key_found(data, sector_num, MfClassicKeyA, key);
        }
        // Load Access Bits
        // Access bits mask 0b0000001111000000 = 0x03c0
        if((block_unknown_bytes_mask & 0x03c0) == 0) {
            mf_classic_set_block_read(data, block_num, &block_tmp);
        }
        // Load Key B
        // Key B mask 0b1111110000000000 = 0xfc00
        if((block_unknown_bytes_mask & 0xfc00) == 0) {
            uint64_t key = nfc_util_bytes2num(sec_tr_tmp->key_b, sizeof(sec_tr_tmp->key_b));
            mf_classic_set_key_found(data, sector_num, MfClassicKeyB, key);
        }
    } else {
        if(block_unknown_bytes_mask == 0) {
            mf_classic_set_block_read(data, block_num, &block_tmp);
        }
=======
    if(instance->protocol_data) {
        nfc_devices[instance->protocol]->reset(instance->protocol_data);
>>>>>>> release
    }
}

NfcProtocol nfc_device_get_protocol(const NfcDevice* instance) {
    furi_assert(instance);
    return instance->protocol;
}

const NfcDeviceData* nfc_device_get_data(const NfcDevice* instance, NfcProtocol protocol) {
    return nfc_device_get_data_ptr(instance, protocol);
}

const char* nfc_device_get_protocol_name(NfcProtocol protocol) {
    furi_assert(protocol < NfcProtocolNum);

    return nfc_devices[protocol]->protocol_name;
}

const char* nfc_device_get_name(const NfcDevice* instance, NfcDeviceNameType name_type) {
    furi_assert(instance);
    furi_assert(instance->protocol < NfcProtocolNum);

    return nfc_devices[instance->protocol]->get_name(instance->protocol_data, name_type);
}

const uint8_t* nfc_device_get_uid(const NfcDevice* instance, size_t* uid_len) {
    furi_assert(instance);
    furi_assert(instance->protocol < NfcProtocolNum);

    return nfc_devices[instance->protocol]->get_uid(instance->protocol_data, uid_len);
}

bool nfc_device_set_uid(NfcDevice* instance, const uint8_t* uid, size_t uid_len) {
    furi_assert(instance);
    furi_assert(instance->protocol < NfcProtocolNum);

    return nfc_devices[instance->protocol]->set_uid(instance->protocol_data, uid, uid_len);
}

void nfc_device_set_data(
    NfcDevice* instance,
    NfcProtocol protocol,
    const NfcDeviceData* protocol_data) {
    furi_assert(instance);
    furi_assert(protocol < NfcProtocolNum);

    nfc_device_clear(instance);

    instance->protocol = protocol;
    instance->protocol_data = nfc_devices[protocol]->alloc();

    nfc_devices[protocol]->copy(instance->protocol_data, protocol_data);
}

void nfc_device_copy_data(
    const NfcDevice* instance,
    NfcProtocol protocol,
    NfcDeviceData* protocol_data) {
    furi_assert(instance);
    furi_assert(protocol < NfcProtocolNum);
    furi_assert(protocol_data);

    if(instance->protocol != protocol) {
        furi_crash(NFC_DEV_TYPE_ERROR);
    }

    nfc_devices[protocol]->copy(protocol_data, instance->protocol_data);
}

bool nfc_device_is_equal_data(
    const NfcDevice* instance,
    NfcProtocol protocol,
    const NfcDeviceData* protocol_data) {
    furi_assert(instance);
    furi_assert(protocol < NfcProtocolNum);
    furi_assert(protocol_data);

    return instance->protocol == protocol &&
           nfc_devices[protocol]->is_equal(instance->protocol_data, protocol_data);
}

bool nfc_device_is_equal(const NfcDevice* instance, const NfcDevice* other) {
    furi_assert(instance);
    furi_assert(other);

    return nfc_device_is_equal_data(instance, other->protocol, other->protocol_data);
}

void nfc_device_set_loading_callback(
    NfcDevice* instance,
    NfcLoadingCallback callback,
    void* context) {
    furi_assert(instance);
    furi_assert(callback);

    instance->loading_callback = callback;
    instance->loading_callback_context = context;
}

bool nfc_device_save(NfcDevice* instance, const char* path) {
    furi_assert(instance);
    furi_assert(instance->protocol < NfcProtocolNum);
    furi_assert(path);

    bool saved = false;
    Storage* storage = furi_record_open(RECORD_STORAGE);
    FlipperFormat* ff = flipper_format_buffered_file_alloc(storage);
    FuriString* temp_str = furi_string_alloc();

    if(instance->loading_callback) {
        instance->loading_callback(instance->loading_callback_context, true);
    }

    do {
        // Open file
        if(!flipper_format_buffered_file_open_always(ff, path)) break;

        // Write header
        if(!flipper_format_write_header_cstr(ff, NFC_FILE_HEADER, NFC_CURRENT_FORMAT_VERSION))
            break;

        // Write allowed device types
        furi_string_printf(temp_str, "%s can be ", NFC_DEVICE_TYPE_KEY);
        for(NfcProtocol protocol = 0; protocol < NfcProtocolNum; ++protocol) {
            furi_string_cat(temp_str, nfc_devices[protocol]->protocol_name);
            if(protocol < NfcProtocolNum - 1) {
                furi_string_cat(temp_str, ", ");
            }
        }

        if(!flipper_format_write_comment(ff, temp_str)) break;

        // Write device type
        if(!flipper_format_write_string_cstr(
               ff, NFC_DEVICE_TYPE_KEY, nfc_devices[instance->protocol]->protocol_name))
            break;

        // Write UID
        furi_string_printf(temp_str, "%s is common for all formats", NFC_DEVICE_UID_KEY);
        if(!flipper_format_write_comment(ff, temp_str)) break;

        size_t uid_len;
        const uint8_t* uid = nfc_device_get_uid(instance, &uid_len);
        if(!flipper_format_write_hex(ff, NFC_DEVICE_UID_KEY, uid, uid_len)) break;

        // Write protocol-dependent data
        if(!nfc_devices[instance->protocol]->save(instance->protocol_data, ff)) break;

        saved = true;
    } while(false);

    if(instance->loading_callback) {
        instance->loading_callback(instance->loading_callback_context, false);
    }

    furi_string_free(temp_str);
    flipper_format_free(ff);
    furi_record_close(RECORD_STORAGE);

    return saved;
}

static bool nfc_device_load_uid(
    FlipperFormat* ff,
    uint8_t* uid,
    uint32_t* uid_len,
    const uint32_t uid_maxlen) {
    bool loaded = false;

    do {
        uint32_t uid_len_current;
        if(!flipper_format_get_value_count(ff, NFC_DEVICE_UID_KEY, &uid_len_current)) break;
        if(uid_len_current > uid_maxlen) break;
        if(!flipper_format_read_hex(ff, NFC_DEVICE_UID_KEY, uid, uid_len_current)) break;

        *uid_len = uid_len_current;
        loaded = true;
    } while(false);

    return loaded;
}

static bool nfc_device_load_unified(NfcDevice* instance, FlipperFormat* ff, uint32_t version) {
    bool loaded = false;

    FuriString* temp_str = furi_string_alloc();

    do {
        // Read Nfc device type
        if(!flipper_format_read_string(ff, NFC_DEVICE_TYPE_KEY, temp_str)) break;

        // Detect protocol
        NfcProtocol protocol;
        for(protocol = 0; protocol < NfcProtocolNum; ++protocol) {
            if(furi_string_equal(temp_str, nfc_devices[protocol]->protocol_name)) {
                break;
            }
        }

        if(protocol == NfcProtocolNum) break;

        nfc_device_clear(instance);

        instance->protocol = protocol;
        instance->protocol_data = nfc_devices[protocol]->alloc();

        // Load UID
        uint8_t uid[NFC_DEVICE_UID_MAX_LEN];
        uint32_t uid_len;

        if(!nfc_device_load_uid(ff, uid, &uid_len, NFC_DEVICE_UID_MAX_LEN)) break;
        if(!nfc_device_set_uid(instance, uid, uid_len)) break;

        // Load data
        if(!nfc_devices[protocol]->load(instance->protocol_data, ff, version)) break;

        loaded = true;
    } while(false);

    if(!loaded) {
        nfc_device_clear(instance);
    }

    furi_string_free(temp_str);
    return loaded;
}

static bool nfc_device_load_legacy(NfcDevice* instance, FlipperFormat* ff, uint32_t version) {
    bool loaded = false;

    FuriString* temp_str = furi_string_alloc();

    do {
        // Read Nfc device type
        if(!flipper_format_read_string(ff, NFC_DEVICE_TYPE_KEY, temp_str)) break;

        nfc_device_clear(instance);

        // Detect protocol
        for(NfcProtocol protocol = 0; protocol < NfcProtocolNum; protocol++) {
            instance->protocol = protocol;
            instance->protocol_data = nfc_devices[protocol]->alloc();

            // Verify protocol
            if(nfc_devices[protocol]->verify(instance->protocol_data, temp_str)) {
                uint8_t uid[NFC_DEVICE_UID_MAX_LEN];
                uint32_t uid_len;

                // Load data
                loaded = nfc_device_load_uid(ff, uid, &uid_len, NFC_DEVICE_UID_MAX_LEN) &&
                         nfc_device_set_uid(instance, uid, uid_len) &&
                         nfc_devices[protocol]->load(instance->protocol_data, ff, version);
                break;
            }

            nfc_device_clear(instance);
        }

    } while(false);

    furi_string_free(temp_str);
    return loaded;
}

bool nfc_device_load(NfcDevice* instance, const char* path) {
    furi_assert(instance);
    furi_assert(path);

    bool loaded = false;
    Storage* storage = furi_record_open(RECORD_STORAGE);
    FlipperFormat* ff = flipper_format_buffered_file_alloc(storage);

    FuriString* temp_str;
    temp_str = furi_string_alloc();

    if(instance->loading_callback) {
        instance->loading_callback(instance->loading_callback_context, true);
    }

    do {
        if(!flipper_format_buffered_file_open_existing(ff, path)) break;

        // Read and verify file header
        uint32_t version = 0;
        if(!flipper_format_read_header(ff, temp_str, &version)) break;

        if(furi_string_cmp_str(temp_str, NFC_FILE_HEADER)) break;
        if(version < NFC_MINIMUM_SUPPORTED_FORMAT_VERSION) break;

        // Select loading method
        loaded = (version < NFC_UNIFIED_FORMAT_VERSION) ?
                     nfc_device_load_legacy(instance, ff, version) :
                     nfc_device_load_unified(instance, ff, version);

    } while(false);

    if(instance->loading_callback) {
        instance->loading_callback(instance->loading_callback_context, false);
    }

    furi_string_free(temp_str);
    flipper_format_free(ff);
    furi_record_close(RECORD_STORAGE);

    return loaded;
}
